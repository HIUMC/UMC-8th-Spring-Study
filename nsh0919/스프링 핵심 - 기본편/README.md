# 스프링 핵심 기본편 강의 정리

## 섹션 2 객체지향설계와 스프링
### 스프링 프레임워크
스프링의 핵심 기술들을 제공하는 기본 프레임워크를 의미한다.  
   
-DI 컨테이너, AOP   
-스프링 MVC (웹 기술)
-트랜잭션, JDBC, ORM, XML (데이터 접근)   
-테스트 기능 지원   
-자바뿐만 아니라 코틀린,그루비 언어도 지원   

### 스프링 부트
스프링을 편리하게 사용 할수 있게 도와주는 도구   
-단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성   
-Tomcat 같은 웹 서버가 내장 되어있음   
-손쉬운 빌드 구성을 위한 starter 종속성 제공

### 스프링의 핵심 
스프링은 자바 언어 기반의 프레임워크이고,   
자바 언어의 가장 큰 특징은 '객체 지향 언어'라는 것   
스프링은 DI,AOP 등등의 기능을 통해 살려내는 프레임워크임   

### 객체 지향 특징
-추상화   
복잡한 내용은 숨기고, 중요한 정보만 보여주는것   
-캡슐화   
객체의 속성과 기능을 하나로 묶고, 외부에서 함부로 접근 못하게 하는 것   
-상속   
기존 클래스을 재사용하여 새로운 클래스를 만드는 것   
-다형성   
같은 메서드 호출 이이어도 객체에 따라 다르게 동작하는 것   

### 객체 지향 프로그래밍
컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나   
여러 개의 독립된 단위, 즉 "객체"들의 모임으로 파악하고자 하는 것   
각각의 객체는 메시지를 주고 받고, 데이터를 처리할 수 있음   
프로그램을 유연하고 변경이 용이하게 만들어줌   

### 역할과 구현을 분리
역할과 구현으로 구분하면 단순해지고 변경도 편리해짐   

자바 언어의 다형성을 활용하여   
역할 = 인터페이스   
구현 = 인터페이스를 구현한 클래스, 구현 객체   
이런 방식으로 구현한다.

### 다형성의 본질
인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할수 있음   
즉, 클라이언트를 변경 하지 않고 서버의 구현 기능을 유연하게 변경이 가능함

### 스프링과 객체 지향
스프링은 다형성을 극대화해서 이용할 수 있게 도와줌   
제어의 역전(IoC)과 의존관계 주입(DI)은 다형성을 활용해서   
역할의 구현을 편리하게 다룰수 있게 지원함   

### SOLID
좋은 객체 지향 설계를 위한 5가지 원칙   
SRP:단일 책임 원칙   
OCP:개방-패쇄 원칙   
LSP:리스코프 치환 원칙   
ISP:인터페이스 분리 원칙   
DIP:의존관계 연적 원칙   

### SRP (Single responsibility principle)
"단일 책임 원칙"   
한 클래스는 단 하나의 책임만 가져야함   
책임의 기준은 '변경'   
변경이 있을때 파급효과가 적어야함   

### OCP (Open/closed principle)
"개방-폐쇄 원칙"   
확장에는 열려있으나 변경에는 닫혀있어야 함   
다형성을 활용하여 역할과 구현을 분리하는 것   

### LSP (Liskov substitution principle)
"리스코프 치환 원칙"   
하위타입의 인스턴스로 바꿀때, 프로그램의 정확성을 깨뜨리지 말아야함   
단순히 컴파일을 성공하는 걸 넘어서   
기능의 구현이 정확해야함을 의미   

### ISP (Interface segregation principle)
"인터페이스 분리 원칙"   
특정 클라이언트를 위한 인터페이스 여러 개가   
범용 인터페이스 하나보다 나음   
인터페이스가 명확해지고 관련없는 다른 클라이언트에 영향을 안줌    

### DIP (Dependency inversion principle)
"의존관계 역전 원칙"   
구체화에 의존하지 말고 추상화에 의존해야함    
구현체에 의존하지 말고 인터페이스에 의존하라는 의미   

### OCP,DIP 위반 사례
```java
public class MemberService {
    
//  private MemberRepository memberRepository = new MemoryMemberRepository();
    private MemberRepository memberRepository = new JdbcMemberRepository();
}
```
위 코드는 구현 클래스를 변경하는 코드이다.   
구현 객체를 변경하려면 클라이언트 코드를 변경해야하므로   
OCP 원칙 위반이고   
클라이언트가 직접 구현 클래스를 선택하므로   
DIP 위반이다.   

### 스프링 컨테이너
스프링은 DI 컨테이너를 제공하여   
이러한 문제를 해결함   
OCP,DIP를 준수하며, 의존관계를 주입할수 있게 해줌   

## 섹션 3,4 스프링 핵심 원리 이해 
### 설정 클래스 별도 생성 (역할의 분리)
섹션 2에서 언급했듯   
OCP와 DIP를 위반하지 않으면서 어떻게 의존관계를 주입할까?   
기존 코드는 하나의 코드가 "기능 동작" 뿐만 아니라   
"구현 객체 생성,연결" 역할도 가지고 있었다.   
의존관계를 주입해주는 코드를 따로 만들어서 역할을 분리하여야한다.   
그리고 그 코드가 의존관계를 위해 인스턴스를 생성해야 하므로   
구현체 코드에 생성자 메서드를 추가해야한다.
그러면 OCP,DIP를 준수할수 있게 된다.   

### IoC (Inversion of Control)
위처럼 의존관계를 주입하는 코드를 따로 만들면   
프로그램의 제어흐름을 구현체가 직접 제어하는 것이 아니라   
외부에서 제어하는 형태가 된다.   
이를 '제어의 역전'(IoC)라고 한다.   

### DI (Dependency Injection)
의존관계는 정적인 '클래스 의존관계'와 동적인 '객체 의존관계'로    
분리해서 생각해야함
클래스 의존관계는 클래스가 사용하는 import 코드를 보고 의존관계를 파악할수있다.   
하지만 실제 어떤 객체가 주입되는지는 알 수 없다.   
객체 의존관계는 애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존관계임.   

### 컨테이너
이렇게 의존관계를 연결해주는 것을 IoC 컨테이너 또는 DI 컨테이너라고 함.   

### 스프링을 사용하여 DI 적용
DI를 적용하는 역할의 클래스에 @Configuration 어노테이션을 붙여주고   
각 메서드에 @Bean 어노테이션을 붙여준다.    

### 스프링 컨테이너 적용하기
ApplicationContext를 스프링 컨테이너라 한다.   
스프링 컨테이너는 @Configuration이 붙은 코드를 찾아   
여기서 @Bean이 적힌 메서드를 호출하여 반환된 객체를 등록한다.   
getBean 메서드를 사용하여 찾을수 있다.   

## 섹션 5 스프링 컨테이너와 스프링 빈
### 스프링 컨테이너 생성
ApplicationContext를 스프링 컨테이너를 의미하는 인터페이스이다.   
AnnotationConfigApplicationContext는 위 인터페이스의 구현 클래스이다.   
그러므로 스프링 컨테이너를 생성하는 예시는   
ApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class);   

### 스프링 컨테이너 생성과정
위에 설명했던 대로 컨테이너 생성 코드를 넣으면   
1-파라미터로 받은 클래스(config)를 구성 정보로 지정하여 컨테이너를 생성한다.   
2-스프링 컨테이너는 구성 정보를 사용하여 스프링 빈을 등록함
3-구성 정보를 참고하여 의존관계를 주입

## 섹션 6 싱글톤 컨테이너
### 웹 어플리케이션과 싱글톤
웹 애플리케이션은 보통 여러 고객이 동시에 요청을 한다.   
그래서 기존 순수 자바 DI 컨테이너로는   
요청마다 새로운 객체를 생성하기 때문에 메모리 낭비가 심하다.   

### 싱글톤 패턴
이에 대한 해결방안은 객체가 1개만 생성되고   
서로 공유하도록 설계하는 싱글톤 패턴으로 설계하는 것이다.   
우선, 생성자를 private으로 설정하여 new 키워드를 사용하지 못하게 하고   
대신 인스턴스가 필요할때, static 메서드를 통해 반환하도록 설계하는 것이다.   
그러면 새로운 객체를 생성하는 대신 동일한 객체를 호출하는 방식으로 사용할수 있는 것이다.   
하지만 이러한 방식에는 문제점이 있다.   
-코드가 많아짐   
-클라이언트가 구체 클래스에 의존함 (DIP 위반)   
-위의 이유로 OCP 위반의 위험성도 있음   
-테스트가 어려움   
-private 생성자라서 자식 클래스를 만들기 힘듬

### 싱글톤 컨테이너
스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하면서   
객체 인스턴스를 싱글톤으로 관리해준다.   
스프링 빈을 등록할때, 기본적으로 싱글톤으로 등록한다.
그래서 싱글톤 패턴을 위한 지저분한 코드가 들어갈 필요가 없고   
DIP,OCP,테스트,private 생성자로부터 자유롭게 사용가능하다.   

### 싱글톤 방식의 주의점
하지만 어떤방식으로 싱글톤을 사용하든   
싱글톤 방식은 여러 클라이언트가 하나의 객체 인스턴스를 공유하기 때문에   
상태를 유지하지 않도록 설계해야한다. (stateless)   
가급적 읽기만 가능해야하므로 필드 대신    
자바가 공유하지 않는 지역변수, 파라미터, ThreadLocal 등을 사용해야함   

### @Configuration과 바이트코드 조작을 통한 싱글톤 보장
그럼 만약 2개의 클래스에서 new 메서드를 통해 동일한 클래스를 호출할때   
2개의 new 메서드가 호출되는데 싱글톤을 어떻게 보장하는 걸까?   
스프링은 CGLIB라는 바이트 조작 라이브러리를 통해   
호출한 클래스에 내부 기술을 적용한다.   
그래서 새로운 객체를 호출할때   
스프링 컨테이너에 등록이 되어있지 않은 객체는    
기존 로직을 호출하여 스프링 빈으로 등록하고   
스프링 컨테이너에 이미 등록이 되어있다면    
스프링 컨테이너에 찾아서 반환한다.   

### @Configuration없이 @Bean만 적용하면?
CGLIB는 @Configuration에 있는 라이브러리이므로   
@Bean만 사용하면 스프링 빈으로 등록되지만 싱글톤을 보장하지는 않음

## 섹션 7 컴포넌트 스캔
### 컴포넌트 스캔과 의존관계 자동 주입 
스프링 빈으로 등록할 클래스에 @Component를 붙히고   
생성자에는 @Autowired를 붙힌다.    
설정 정보 클래스에 @ComponentScan을 붙힌다.   
그러면 @ComponentScan이 붙은 클래스를 설정정보로 하여
@Component가 붙은 클래스를 전부 등록해준다.   
그리고 @Autowired를 통해 의존관계도 자동으로 주입해준다.   

### 컴포넌트 스캔 대상
@Controller,@Repository,@Service,@Configuration은    
@Component를 포함하고 있어 스프링을 지원한다.

### 필터
includeFilters : 컴포넌트 스캔 대상을 추가로 지정한다.
excludeFilters : 컴포넌트 스캔에서 제외할 대상을 지정한다.



