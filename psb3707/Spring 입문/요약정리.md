## 1. 프로젝트 설정

- Gradle
    - 프로젝트에서 필요한 모든 의존관계에 포함된 라이브러리들을 자동으로 불러와 관리한다.
- 핵심 라이브러리들
    - spring-boot-starter-web  : 스프링으로 웹 어플리케이션을 개발할 때 기본적으로 포함하는 의존성 모음
        - spring-webmvc  : Spring 의 MVC 프레임워크
        - spring-boot-starter-tomcat : 내장 톰캣 서버
        - spring-boot-starter-logging : Slf4j + logback 과 같은 로깅 라이브러리
    - spring-boot-starter(공통) : 스프링 부트 + 스프링 코어

## 2. View

- Welcome Page
    - resources/static/index.html 로 html파일을 만들어준뒤  localhost:8080로 접속하면 index.html을 자동으로 랜더링
- thymeleaf 템플릿 엔진

    ```java
    @Controller
    public class HelloController {
    	
    		@GetMapping("hello")
    		public String hello(Model model){ // model 객체 자동생성
    				model.addAttribute("data", "hello!!"); // model 의 키는 data 값은 hello!!로 전달
    				return "hello"; // resources/templates 에서 뷰 리졸버가 hello.html을 탐색
    		}
    }
    ```


## 3. 빌드하고 실행하기

- `./gradlew build` : 프로젝트를 빌드하여 .jar 파일 생성
- 빌드된 .jar 파일은 /build/libs에 -SNAPHOT.jar로 저장
- java -jar 프로젝트 파일명 : 프로젝트 실행
- `./gradlew clean` : 빌드 폴더 삭제

## 4. 스프링 기반 웹 어플리케이션

1. 정적 컨텐츠 제공
    - Spring 톰캣은 static/~.html 파일의 경우 localhost:8080/~.html 로 요청이 들어올 시 컨트롤러와 매핑여부를 확인한 후 정적 컨텐츠를 바로 반환한다.
2. MVC 와 템플릿 엔진
3. API
    - 동작방식
        - localhost:8080/hello-api로 접근
        - 내장 톰캣 서버가 매핑된 컨트롤러로 요청 전달
        - `@ResponseBody` 로 명시된 컨트롤러 메서드에서 객체를 반환해야하는 경우 `HttpMessageConverter` 동작
        - 문자열인 경우 ⇒ `StringHttpMessageConverter`  동작
        - 객체인 경우 ⇒ `MappingJackson2 HttpMessageConverter` 동작

    ```java
    @GetMapping("hello-string")
    @ResponseBody // http 응답 메세지의 body부분에 직접 반환 데이터를 삽입해 응답하도록 지시
    public String helloString(@RequestParam("name") String name){
    		return "hello" + name; // 뷰 리졸버가 관여하지 않음
    }
    
    @GetMapping("hello-api")
    @ResponseBody
    public Hello helloApi(@RequestParam("name") String name){
    		Hello hello = new Hello();
    		hello.setName(name);
    		return hello; // json 형식으로 변환하여 반환
    }
    
    static class Hello{
    		private String name;
    		
    		public String getName(){
    				return name;
    		}
    		
    		public void setName(String name){
    				this.name = name;
    		}
    }
    ```


## 스프링 빈과 의존관계

- 컴포넌트 스캔
    - `@Component` 어노테이션을 사용하면 스프링이 어플리케이션 로딩 시점에 스프링 컨테이너에 해당 클래스를 자동 등록

    ```java
    @Controller // 스프링의 컴포넌트 스캔 기능을 이용해 빈으로 자동 등록
    public class HelloController{
    	private final HelloService helloService; // @Service 어노테이션으로 등록된 빈이라면 자동 의존관계 주입
    	
    	@Autowired // 의존관계 주입
    	public HelloController(HelloService helloService){
    		this.helloService = helloService;   // @RequiredArgsConstructor하나로 요약 가능
    	}
    }
    ```

- 자바 코드로 등록

    ```java
    @Configuration // 스프링에게 아래 클래스가 설정 클래스임을 명시
    public class SpringConfig{
    	
    	@Bean // 빈으로 수동등록
    	public HelloService helloService(){
    		return new HelloService(helloRepository()); // 빈으로 등록된 helloRepository에 대한 의존관계 주입
    	}
    	
    	@Bean
    	public HelloRepository helloRepository(){
    		return new HelloRepository();
    	}
    	
    }
    ```


## 데이터 접근 기술

1. JdbcTemplate
    - 순수 jdbc의 복잡한 데이터 접근 코드를 줄이고 깔끔하게 처리
    - but, sql은 직접 작성해야함

    ```java
    @Repository
    public class MemberRepository{
    	
    		private final JdbcTemplate jdbcTemplate;
    	
    		public MemberRepository(DataSource dataSource){
    				this.jdbcTemplate = new JdbcTemplate(dataSource); // dataSource 빈 주입
    		}
    		
    		public Member save(Member member){
    				SimpleJdbcInsert jdbcInsert = new SimpleJdbcInsert(jdbcTemplate);
    				jdbcInsert.withTableName("member").usingGeneratedKeyColumns("id"); // 대상 테이블 지정
    				Map<String, Object> parameters = new HashMap<>();
    				
    				parameters.put("name", member.getName()); // 삽입할 칼럼의 데이터 할당
    				
    				Number key = jdbcInsert
    				.executeAndReturnKey(new MapSqlParameterSource(parameters)); // 생성한 후 키 반환
    				member.setId(key.longValue());
    				
    				return member;
    		}
    }
    				
    				 
    ```

2. JPA
    - EntityManager
        - JPA를 사용하면 스프링이 자동으로 생성 DataSource 를 가지고 있음
        - 영속성 컨텍스트를 관리
        - **jpql : 객체 지향 쿼리 언어**로, SQL과 문법은 비슷하지만 **대상은 테이블이 아닌 엔티티(Entity)

    ```java
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa' // jpa 의존성 주입
    ```

    ```java
    @Entity // ORM 을 위한 객체 - DB와 매핑
    public class Member{
    		
    		@Id @GeneratedValue(strategy = GenerationType.IDENTITY) // DB에서 레코드 생성마다 자동으로 1씩 PK값 증가
    		private Long id;
    		
    		private String name;
    }
    ```

    ```java
    @Repository
    public class MemberRepository{
    		
    		private final EntityManager em;
    		
    		public MemberRepository(EntityManager em){
    				this.em = em; // 엔티티매니저 주입
    		}
    		
    		public Member save(Member member){
    				em.persist(member); // 객체를 영속상태로 전환! jpa가 자동으로 insert 쿼리 생성
    		}
    		
    		public Optional<Member> findById(Long id){
    				Member member = em.find(Member.class, id); // pk기반 데이터 조회
    				return Optional.ofNullable(member);
    		}
    		
    		public Optional<Member> findByName(String name){
    				String jpql = "SELECT u FROM Member m WHERE m.name= :name"; // jpql 작성
    				Member member = em.createQuery(jpql, Member.class)
                  .setParameter("name", "ParkSeungBeom")
                  .getSingleResult(); 
            return Optional.ofNullable(member);
        }
      }
    ```


## AOP

- 핵심관심사항과 공통관심사항을 분리한다.
    - 만약 이 둘이 같은 로직으로 묶여 있다면? ⇒ 코드가 복잡해지고 유지보수가 어려워진다.
    - 공통 관심 사항( 로깅, 트랜잭션 관리) 로직을 모듈화 하여 핵심 비즈니스 로직과 분리한다.

```java
@Aspect // 공통 기능을 정의한 모
public class TimeTraceAop{
	
		@Around("execution(* hello.hellospring..*(..))") // 해당 디렉토리 하위에 모두 적용
		public Object excute(ProceedingJoinPoint joinPoint) throws Trowable{
			
				long start = System.currentTimeMills();
			
				System.out.println("START: " + joinPoint.toString());
			
				try{
						return joinPoint.proceed(); // 원래 메서드 실행
				}finally{
						long finish = System.currentTimeMills();
						long timeMs = finish - start;
					
						System.out.println("END: " + joinPoint.toString() + " " + timeMs + "ms");
				}
		}
}
		
```

## 질문사항

- Spring Data Jpa 에서 사용하는 JpaRepository<Object, PK타입> 인터페이스는 이를 상속한 인터페이스에 대해 Spring Data Jpa에서 사용하는 다양한 기능들을 제공합니다. 하지만 단순 인터페이스를 상속하고 이를 구현한 적이 없는데 이와 같은 동작이 가능한 이유는 뭘까요?

- 실제 프로젝트에서 AOP을 적용할만한 이슈가 많이 있을까요??