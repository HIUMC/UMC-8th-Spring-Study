### section2 - 객체 지향 설계와 스프링

[스프링이란?]

- 스프링 프레임워크는 스프링 부트를 통해서 사용
    - 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크
- 스프링 부트
    - Tomcat 웹 서버 내장
    - 스프링 애플리케이션 쉽게 생성 가능

[좋은 객체 지향 프로그래밍이란?]

- 유연하고 변경이 용이한 프로그램을 만들어야 함 —> 다형성

[좋은 객체 지향 설계의 5가지 원칙(SQLID]

- SRP: 단일 책임 원칙
    - 하나의 클래스는 하나의 책임만 가져야 함.
    - 변경이 있을 때 파급 효과가 적어야 함
        - ex) 객체의 생성과 사용을 분리
- OCP: 개방-폐쇄 원칙
    - 확장에는 열려있으나 변경에는 닫혀 있어야 함
- LSP: 리스코프 치환 원칙
    - 프로그램 객체는 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 함
    - 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 함.
- ISP: 인터페이스 분리 원칙
    - 여러 인터페이스로 분리하면 인터페이스가 명확해지고, 대체 가능성이 높아진다!
- DIP: 의존 관계 역전 원칙
    - 구현 클래스에 의존하지 말고, 인터페이스에 의존하자


### section3 - 스프링 핵심 원리 이해1 - 예제 만들기

스프링 프레임워크 없이 순수 자바 프로젝트 만들어보기

[프로젝트 생성]

- Ctrl+Alt+s  : 설정 창

[회원 도메인 설계 및 개발]

- 클래스 다이어그램 vs 객체 다이어그램
    - 객체 다이어그램에서 실제 참조되는 객체들의 연관 관계를 나타냄
- Alt+Insert : 생성 창
- 단축키 확인하기 : 설정에서 검색하면 알 수 있음

[주문과 할인 도메인 개발 & 테스트]

- 역할과 구현 분리 → 저장소, 서비스 유연하게 변경 가능!
- Assertions 쓸 때 `org.assertj.core.api.Assertions` 사용하기



### section4 - 스프링 핵심 원리 이해2 - 객체 지향 원리 적용

[새로운 할인 정책 개발]

- 정률 할인 정책 추가 - 클래스 추가하기만 하면 됨

[적용 및 문제점]

- 문제 - 객체지향 설계 원칙에 어긋남
    - 인터페이스와 구현 클래스에 모두 의존하고 있음 (목표는 인터페이스에만 의존하기)→ DIP 위반
    - FixDiscountPolicy에서 RateDiscountPolicy로 변경하면 클라이언트 소스 코드도 함께 변경해야 함→ OCP 위반
- 해결
    - 누군가 클라이언트인 ‘OrderServiceImpl’에 DiscountPolicy 구현 객체를 대신 생성하고 주입해주어야 함 —> AppConfig


[관심사의 분리] * 왕중요!!

- OrderServiceImpl 이 직접 객체를 생성하면 안된다!
- 공연 기획자 - AppConfig
    - 구현 객체를 생성, 연결하는 별도의 설정 클래스
    - AppConfig 안에서 실제 동작에 필요한 구현 객체 생성 해주기 - 생성자 주입
    - MemberServiceImpl 입장에서 어떤 구현 객체가 들어올 지 알 수 없음. 의존 관계를 외부에서 주입해준다(의존관계 주입)

+final 있으면 반드시 생성자 있어야 함

[AppConfig 리팩터링&새로운 할인 정책 적용]

- AppConfig를 역할이 잘 드러나게 수정해보자. 중복도 제거 함
- AppConfig에서 Fix → Rate로 변경하면 끝!
- 사용 영역, 구성 영역으로 분리됨
    - 구성 영역 - 객체 생성. 코드 수정 필요
    - 사용 영역 - 변경 시 코드 수정 필요 없음!

[좋은 객체 지향 설계의 5가지 원칙 적용]

현재까지 SRP, DIP, OCP 적용함

- SRP(단일 책임 원칙)
    - AppConfig 생성 전 - 클라이언트 객체가 직접 구현 객체 생성, 연결, 실행까지 수행함
    - AppConfig 생성 후 - 객체 생성, 연결 책임은 AppConfig에게, 실행은 클라이언트 객체에게
- DIP(의존관계 역전 원칙)
    - 클라이언트 코드는 추상화에만 의존 —> 인터페이스만으로는 실행할 수 없음 —> AppConfig가 클라이언트 코드 대신 객체 생성하고 의존관계 주입해줌
- OCP
    - 사용 영역과 구성 영역으로 나누어서 확장하는 경우 AppConfig의 구성 영역에서만 변경하면 되도록 함!

[IoC, DI, 컨테이너]

- 제어의 역전 IoC(Inversion of Control)
    - AppConfig에게 제어 흐름이 넘어감.
    - 프레임워크 vs 라이브러리
        - 프레임워크: 내가 작성한 코드를 제어하고, 대신 실행
        - 라이브러리: 내가 작성한 코드가 직접 제어 흐름 담당
- 의존 관계 주입 DI
    - 정적인 클래스 의존 관계
        - import 코드만 보고 판단할 수 있음
    - 동적인 객체 의존 관계
        - 실행해봐야 어떤 객체가 주입 될 지 알 수 있음. 객체 인스턴스 생성 → 참조값 전달 을 통해 연결됨
        - 의존관계 주입을 사용하면 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있음
        - 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있음(클래스 다이어그램을 수정할 필요 없이 객체 다이어그램만 수정하면 됨!)
- IoC 컨테이너, DI 컨테이너
    - AppConfig처럼 객체를 생성하고 관리하면서 의존관계를 연결해 줌
    - 최근에는 DI 컨테이너라고 함(의존 관계 주입에 초점을 맞춤. 어셈블러, 오브젝트 팩토리 등으로 불리기도…)

[스프링으로 전환하기]

@Configuration,

각 메서드에 @Bean 추가 —> 각각 스프링 컨테이너에 등록됨

App에 AnnotationConfigApplicationContext 추가

- 스프링 컨테이너
    - ApplicationContext : 스프링 컨테이너
    - @Configuration 붙은 Config를 설정 정보로 사용
    - @스프링 빈 : Bean 붙은 메서드 호출 → 반환된 객체를 스프링 컨테이너에 등록. 등록된 객체
        - getBean 메서드를 통해 찾을 수 있음!